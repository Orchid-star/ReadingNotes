# 第5章 CPU调度

进程之间切换CPU，操作系统可以提高计算机的吞入率。

CPU调度是多道程序操作系统的基础。



## 5.1 基本概念

当一个进程必须等待时，操作系统会从该进程拿走CPU的使用权，而将CPU交给其他进程。



### 5.1.1 CPU-I/O区间周期

进程执行由CPU执行和I/O等待周期组成。



### 5.1.2 CPU调度程序

每当CPU空闲时，操作系统依靠**短期调度程序**（short-term scheduler)或CPU调度程序选择就绪队列种的一个进程进行执行。



### 5.1.3 抢占调度



### 5.1.4 分配程序

**分配程序**（dispatcher)是一个模块，负责将CPU的控制交给由短期调度程序选择的进程。功能包括：

- 切换上下文
- 切换到用户模式
- 跳转到用户程序的合适位置，以重新启动程序。



## 5.2 调度准则

- CPU使用率
- 吞吐量
- 周转时间
- 等待时间
- 相应时间



### 5.3 调度算法

CPU调度处理是从就绪队列中选择进程并为之分配CPU的问题，有多种不同的CPU调度算法。



### 5.3.1 先到先服务调度

**先到先服务调度算法**（first-come, first-served, **FCFS**)

先请求CPU的进程先分配到CPU，该策略可以使用FIFO队列来容易的实现。

该策略下进程平均等待时间通常较长，CPU和设备的使用率变得更低。



### 5.3.2 最短作业优先调度

**最短作业优先调度算法**（shortest-job-first(SJF) scheduling algorithm)。CPU空闲时，选择具有最短CPU区间的进程执行。

该算法最佳。



### 5.3.3 优先级调度

通过外部或内部设定进程的优先级，根据进程的优先级来决定进程的调度。



### 5.3.4 轮转法调度



### 5.3.5 多级队列调度

**多级队列调度算法**将就绪队列分成多个独立队列，每个队列有自己的调度算法。队列之间也必须有调度，通常采用固定优先级抢占调度。



### 5.3.6 多级反馈队列调度

**多级反馈队列调度算法**相较于多级队列调度，允许进程在队列之间移动。





## 5.4 多处理器调度



### 5.4.1 多处理器调度的方法

**非对称多处理**

让一个处理器处理所有的调度决定、I/O处理以及其他系统活动，其他的处理器只执行用户代码。

**对称多处理（SMP）**

每个处理器自我调度



### 5.4.2 处理器亲和性

由于使缓存无效或重新构建的代价高，绝大多数SMP系统试图避免将进程从一个处理器移至另一个处理器，而是努力使一个进程在同一个处理器上运行，这被称为**处理器亲和性**。

亲和性分为**软亲和性**和**硬亲和性**。



### 5.4 3 负载平衡

在SMP系统中，保持所有处理器的工作负载平衡，以完全利用多处理器的优点，否则，将会产生一个或多个处理器空闲，而其他处理器处于高工作负载状态，并有一系列进程在等待CPU。



## 5.6 操作系统实例

Solaris和Windows XP属于内核线程调度，Linux并不区分进程和线程，讨论Linux调度程序时使用术语**任务**（task)。



### 5.6.1 实例：Solaris调度

采用基于优先级的线程调度。



### 5.6.2 实例：Windows XP调度

采用基于优先级的、抢占调度算法调度线程。（调度时选择优先级高的，以及执行低优先级进程时有高优先级进程就绪，就转而执行高优先级的）

Win32 API定义了一个进程可能属于的一些优先级类型。

每个给定优先级类型的线程拥有相对优先级，包括：

- TIME_CRITICAL
- HIGHEST
- ABOVE_NORMAL
- ...

每个线程的优先级是基于它所属的优先级类型和它在其中的相对优先级。



### 5.6.3 实例：Linux调度

Linux调度程序是抢占的、基于优先级的算法，具有两个独立的优先级范围：从0-99的real-time范围和从100-140的nice范围。这两个范围映射到全局优先级，数值越低优先级越高。



## 5.7 算法评估

### 5.7.1 确定模型

采用预先确定的负荷，计算在给定负荷下每个算法的性能。



### 5.7.2 排队模型



### 5.7.3 模拟



### 5.7.4 实现

编程并观测。