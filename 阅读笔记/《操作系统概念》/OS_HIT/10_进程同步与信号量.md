**进程同步**

需要让进程“走走停停”来保证多进程合作的合理有序。



**信号在进程同步时存在的问题**

*多个生产者*因等待资源而睡眠，而消费者在有空闲资源时发信号唤醒生产者。消费者一个信号只能唤醒一个生产者，但消费者不知道有多少生产者需要被唤醒。



**信号量**

一种特殊整型变量，信号用来睡眠和唤醒，量用来记录。通过对信号量的访问和修改，让多个进程有序推进。

```c++
struct semaphore
{
    int value; //记录资源个数
    PCB *queue; //记录等待在该信号量上的进程
}
P (semaphore s) //消费资源
{
    s.value--;
    if (s.value < 0) {
        sleep(s.queue);
    }
}
V (semaphore s) //产生资源
{
    s.value++;
    if (s.value <= 0) {
        wakeup(s.queue);
    }
}
```

*问题*：

多个进程对同一个信号量的访问，会出现**竞争条件**（和调度有关的共享数据语义错误，由多个进程并发操作共享数据引起）。



**临界区**

临界区：一次只允许一个进程进入的该进程的一段代码（进程中修改共享数据的代码）



**用临界区保护信号量，用信号量实现同步。那如何保护临界区？**

保护原则：

- 互斥进入
- 有空让进
- 有限等待

保护算法：

- 轮换法：不满足有空让进
- 标记法：可能造成无限等待
- Peterson算法：结合标记和轮转两种思想，满足互斥进入、有空让进、有限等待

```c++
//进程P0
flag[0] = true;
turn = 1;
while (flag[1] && turn == 1);
/*临界区*/
flag[0] = false;
/*剩余区*/

//进程P1
flag[1] = true;
turn = 0;
while (flag[0] && turn == 0);
/*临界区*/
flag[0] = false;
/*剩余区*/
```



**硬件原子指令法**

临界区保护的一种方法，从硬件上设计，满足原子操作，保证对信号量修改的完整性。