# 第6章 进程同步

## 6.1 背景

考虑并发进程共享内存中，两个进程分别执行count++和count--，由于这两个操作都是由若干基础机器指令完成，并发执行时，两个操作的基础机器指令混在在一起没有明确的先后执行顺序，导致结果不正确。

不正确状态，是因为允许两个进程并发操作同一变量。



**竞争条件**

多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为**竞争条件**（race condition)。

竞争条件应该避免。



**进程同步(synchronization)和协调（coordination)**

避免竞争条件，确保一段时间内只有一个进程能操作某段内存。



## 6.2 临界区问题

一个进程中可能改写共同变量、更新表、写共同文件等的代码段称为**临界区**（critical section）。当一个进程进入临界区，其他进程就不被允许在临界区内执行。



**临界区问题**

临界区问题是设计一个以便进程协作的协议。

临界区问题的解答满足：

- 互斥（mutual exclusion)   --保证不会有两个进程同时进入临界区
- 前进（progress）   --确定谁能进入临界区且这种选择不能无限推迟
- 有限等待（bounded waiting)   --- 一个进程不能无限等待进入其临界区



**临界区问题的两种方法**

- 抢占内核（preemptive kernel)
- 非抢占内核（nonpreemptive kernel)

非抢占内核不允许处于内核模式的进程被抢占，从根本上不会导致竞争条件。

抢占内核更适合实时编程，更受欢迎。



## 6.3 Peterson算法

peterson算法是经典的基于软件的临界区问题的解答。

```c
int turn;
bool flag[2];
do {
    flag[i] = true;
    turn = j;
    while(flag[j] && turn == j);
    /*
    临界区
    */
    flag[i] = false;
} while(true);
```

1. 如果p1在临界区，p2此时希望进入临界区，会因为while条件成立阻塞
2. 如果p1和p2同时希望进入临界区，但是turn是bool类型，只可能是0或1，所以p1和p2不会同时进入临界区，且因为flag都是true，必定会有一个进入临界区。临界区的进程结束临界区后flag变为false，另一个进程阻塞的while会被立刻释放。



## 6.4 硬件同步

现代计算机系统提供了特殊硬件指令以允许能**原子地（即不可中断地）**检查和修改子的内容或交换两个字的内容（作为不可中断的指令）。



## 6.5 信号量

基于硬件的临界区问题解决方案复杂，对应用程序而言，可以使用**信号量**（semaphore)的同步工具。

**信号量**是除初始化外只能通过两个标准的原子操作wait()和signal()来访问的整数变量。

```c
wait(S){
    while (S <= 0);
    S--;
}
signal(S) {
    S++;
}
```



### 6.5.1 信号量用法

信号量分为两种

- **计数信号量**：值域不受限制
- **二进制信号量**：只能为0或1，也称为**互斥锁**



**信号量的互斥实现**

```c
do {
    waiting(mutex);
    //critical section
    signal(mutex);
    //remainder section
} while(true);
```

**信号量在同步问题中的使用**

```c
//初始化一个信号量为0
int synch = 0;
//进程1
S1:
signal (synch);

//进程2，要求进程1执行了S1语句，进程2才执行S2语句
wait(synch);
S2;
```



### 6.5.2 实现

上述信号量缺点：**忙等待**（busy waiting)

产生忙等待的锁又称**自旋锁**（spinlock)。

信号量的关键之处是：必须确保没有两个进程能同时对同一信号量执行操作wait()和signal()。这属于临界区问题。



### 6.5.3 死锁与饥饿

**死锁（deadlocked)**

两个或多个进程无限等待一个事件，而该事件只能由这些等待进程之一来产生。出现这种状态的进程就称为死锁。

```c
//P0
wait(S);
wait(Q);
signal(S);
signal(Q);
//P1
wait(Q);
wait(S);
signal(Q);
signal(S);
```

**无限期阻塞（indefinite blocking)**或**饥饿（starvation)**

指进程在信号量内无限期等待。



## 6.6 经典同步问题

- 有限缓冲问题
- 读者-写者问题
- 哲学家进餐问题



## 6.7 管程

不正确地使用信号量可能会造成死锁或多进程同时进入临界区的现象。为了处理这类错误，有一种基本的、高级的同步构造，即**管程**（monitor)类型。

