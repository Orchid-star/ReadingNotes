# 第3章 进程

**进程**是现代分时系统的工作单元。

系统由一组进程组成：操作系统进程执行系统代码，用户进程执行用户代码。通过CPU多路复用，所有这些进程可以并发执行。通过进程之间的切换，操作系统能使计算机更为高效。

## 3.1 进程概念

**作业**和**进程**是同一概念，在此不做区分。

### 3.1.1 进程

进程区别于程序代码，进程还包括当前活动，如程序计数器的值和寄存器的内容，还有进程**堆栈段**（包括临时数据，如函数参数、返回地址和局部变量）和**数据段**（包括全局变量），还可能包括**堆**（heap，进程运行期间动态分配的内存）。

**内存中的进程**

包括**文本段**、**数据段**、**堆**、**栈**。文本段即代码段（二进制）。一个可执行文件同时运行两次，虽然文本段相同，但数据段、堆、栈段不同。

### 3.1.2 进程状态

**进程的多种状态**

- **新建**：进程正在被创建
- **运行**：指令正在被运行
- **等待**：进程等待某个事件的发生
- **就绪**：进程等待分配处理器
- **终止**：进程完成执行

一次只能有一个进程可以在一个处理器上运行，但是多个进程可处于就绪或等待状态。



### 3.1.3 进程控制块

**进程控制块**（process control block，PCB，又称任务控制块)是进程在操作系统内的表示。

进程控制块是特定进程信息的集合。包括信息：

- **进程状态** 状态可包括新建、就绪、运行、等待、停止等。
- **程序计数器** 计数器表示进程要执行的下个指令的地址
- **CPU寄存器** 包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器的状态信息等。
- **CPU调度信息** 包括进程的优先级、调度队列的指针和其他调度参数。
- **内存管理信息** 包括基址和界限寄存器的值、页表或段表等
- **记账信息** 包括CPU的时间、实际使用时间、时间界限、记账数据、作业或进程数量等。
- **I/O状态信息** 包括分配给进程的I/O设备列表、打开的文件列表等。

<img src="./images/uint3/CPU在进程间的切换.png" style="zoom:70%;" />



### 3.1.4 线程

线程是进程概念的扩展，是程序具有执行并发任务的能力。



## 3.2 进程调度

**进程调度**指从可用进程集合中选择一个可用进程到CPU上执行。单处理器系统从来不会有超过一个进程在运行。如果有多个进程，余下的则需要等待cpu空闲并重新调度。

### 3.2.1 调度队列

**作业队列**：包括系统中的所有进程。

**就绪队列**：保存内存中就绪的、等待运行的进程。



**Linux中的进程表示**

Linux操作系统的PCB是通过C结构task_struct表示的，该结构包含了表示一个进程所需要的所有信息，包括进程的状态、调度和内存管理信息、打开文件列表和指向父进程和所有子线程的指针。

```c
struct task_struct {
    pid_t pid; //process identifier
    long state; //state of the process
    unsigned int time_slice; //scheduling information
    struct files_struct *files; //list of open files
    struct mm_struct *mm; //address space of this process
};
```

linux内核中，所有活动的进程是通过一个名为task_struct的双向链表表示的。

<img src="./images/uint3/Linux系统中的活动进程.png" style="zoom:70%;" />



**设备队列**

等待特定I/O设备的进程列表称为设备队列。每个设备都有自己的设备队列。

<img src="./images/uint3/就绪队列和各种设备队列.png" style="zoom:67%;" />



**进程调度的表示方法：队列图**

新进程开始处于就绪队列，等待被选中执行。当进程分配到CPU并执行时，可能进行如下活动：

- 进程可能发出一个I/O请求，并被放到I/O队列中
- 进程可能创建一个新的子进程，并等待其结束
- 进程可能会由于中断而强制释放CPU，并被放回到就绪队列中

<img src="./images/uint3/进程调度队列图.png" style="zoom:67%;" />

进程不断进行队列图中的循环直至终止，终止时它将从所有队列中删除，其PCB和资源将得到释放。



### 3.2.2 调度程序

**调度程序**（scheduler）：按某种方式执行进程调度（即进程选择）的程序。



### 3.2.3 上下文切换

中断使CPU从当前任务改变为运行内核子程序。

**上下文切换**（context switch)：CPU切换进程时，保存当前进程的状态并恢复另一个人进程的状态称为上下文切换。



## 3.3 进程操作

### 3.3.1 进程创建

**父子进程**

进程在其执行过程中，能通过创建进程系统调用（create-process system call)创建多个新进程。创建进程称为父进程，新进程称为子进程。每个新进程可以再创建其他进程，形成进程树。



**进程标识符**

大对数操作系统（包括UNIX和Windows)使用进程标识符（pid，整数值)识别进程。

例如ls或cat命令等，是shell调用不同的子进程的命令行接口。



**父子进程执行的两种可能**

- 父进程与子进程并发执行
- 父进程等待，直到某个或全部子进程执行完



**新进程地址空间的两种可能**

- 子进程是父进程的复制品
- 子进程装入另一个新程序



**UNIX系统进程的创建**

fork()系统调用可创建新进程。



**Windows系统进程的创建**

Win32 API使用CreateProcess()创建进程，将特殊程序装入子进程的地址空间。



### 3.3.2 进程终止

当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止。

其他情况如进程通过适当的系统调用（如Win32中的TerminateProcess()能终止另一个进程。





## 3.4 进程间通信



### 3.4.1 共享内存系统



### 3.4.2 消息传递系统



## 3.5 IPC系统的实例



### 3.5.1 实例：POSIX共享内存



### 3.5.2 实例：Mach



### 3.5.3 实例：Windows XP



## 3.6 客户机-服务器系统通信



### 3.6.1 Socket



### 3.6.2 远程过程调用



### 3.6.3 远程方法调用

