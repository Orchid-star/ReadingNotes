# 第2章 套接字类型与协议设置

## 2.1 套接字协议及其数据传输特性

**关于协议（Protocol)**

协议是为了完成数据交换而定好的约定。

**创建套接字**

```c
/**
@param protocol_family 套接字中使用的协议族（Protocol Family)信息
@param type 套接字数据传输类型
@param protocol 计算机间通信使用的协议信息
*/
SOCKET socket(int protocol_family, int type, int protocol);
```

**（1）协议族（Protocol Family)**

协议的分类信息。分类如下：

|   名 称   |        协议族        |
| :-------: | :------------------: |
|  PF_INET  |   IPv4互联网协议族   |
| PF_INET6  |   IPv6互联网协议族   |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET |  底层套接字的协议族  |
|  PF_IPX   |   IPX Novell协议族   |

**PF_INET**对应的IPv4互联网协议族最重要。其他协议族并不常用或尚未普及。

套接字实际采用的最终协议信息是通过socket函数的第三个参数传递的，在指定的协议族范围内通过第一个参数决定第三个参数。

**（2）套接字类型（Type)**

套接字根据使用的数据传输方式，进行类型区分，通过socket函数的第二个参数传递。此处的类型设置，说明socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。

- 套接字类型1 - 面向连接的套接字（SOCK_STREAM)

  数据传输特点：数据不会丢失；按序传输；不存在数据边界；只能与另外一个同样特性的套接字连接。

  数据不会丢失：如果读取缓冲区速度比接收数据慢，缓冲区满了之后，传输端套接字将停止传输。面向连接的套接字会根据接收端的状态传输数据，出错还会提供重传服务。因此除特殊情况外不会发生数据丢失。

  不存在数据边界指定的是：send和recv函数的调用次数没有太大意义。接收数据和发送数据的套接字内部有缓冲buffer（字节数据），通过套接字传输的数据将保存的该buffer。**收到数据并不意味着马上调用read函数，只要不超过buffer容量，则有可能在数据填充满缓冲后通过1次read函数调用读取全部，也有可能分成多次read函数调用进行读取**。

- 套接字类型2 - 面向消息的套接字（SOCK_DGRAM)

  数据传输特点：强调快速传输而非传输顺序；数据可能丢失或损毁；有边界；每次传输的大小有限制。（类比于高速移动的摩托车快递）

  存在数据边界：接收数据的次数应和传输次数相同

**（3）协议的选择**

除同一协议族中存在多个数据传输方式相同的协议外，socket第三个参数可传0.

- IPv4协议族中面向连接的套接字

满足PF_INET和SOCK_STREAM的协议只有IPPROTO_TCP，所以创建方式为：

```c
SOCKET tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
```

又称为**TCP套接字**。

- IPv4协议族中面向消息的套接字

满足PF_INET和SOCK_DGRAM的协议只有IPPROTO_UDP，所以创建方式为：

```c
SOCKET udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
```

又称为**UDP套接字**。

## 2.2 Windows平台下的实现及验证

关于recv或read函数的一点猜测，后续注意查证：

此处假设是面向连接的套接字：发送端套接字调用send发送数据，send指定了本次传输的数据大小。假设数据很大，而缓冲区相对较小，则自然而然send函数会分多次将数据发送出去。因此接收端套接字在调用read函数读取自身缓冲区的数据时，可能会出现缓冲区没有数据的情况（因为数据发送可能是一个时间比较长的过程，数据接收端在接收过程中不断读取数据，读取过程如果很快，而发送端发送较慢且没有发送完）。也就是说，在数据没有传输完成，但是接收端的缓冲区没有数据，此时接收端的read函数会阻塞，直到读到了数据并返回读到的数据长度。随着传输的进行，传输端的数据总算传输完了，接收端的buffer接收到了最后一个字节后，buffer就不会增加数据了。此时read函数继续read，直到把数据全部读取完成，接下来再执行一次read的时候，此时buffer内没有数据了。不同于传输过程中buffer没有数据时，read函数会阻塞，此时read检测到所有数据已经传输完成，所以会直接返回EOF，也就是0。

简而言之：send发送一定长度的数据，read分多次读取数据时，除最后一次返回EOF，其余的read都将返回读取的非0数据长度。返回EOF时表示全部读取完成。例如send一个100字节的数据，接收端多次read到的数据长度可以是20,20,20,20,20,EOF(0)，或30,20,40,10,EOF(0)，但不会出现20,0,30,20,0,30,EOF(0)这种情况。

我们用while循环读取数据，能够保证读取到所有的数据：

```c
while (recv()) {
    
}
```



