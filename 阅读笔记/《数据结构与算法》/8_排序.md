**什么是排序？**

将一组杂乱无章的数据按照一定规律顺次排列起来，即，将无序序列排成一个有序序列（由小到大或由大到小）的运算。

如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。



**排序方法的分类**

- 按数据存储介质：内部排序和外部排序
  - 内部排序  数据量不大，数据在内存，无需内外存交换数据
  - 外部排序  数据量较大，数据在外存（文件排序）
- 按比较器个数：串行排序和并行排序
  - 串行排序  单处理机（同一时刻比较一对元素）
  - 并行排序  多处理机（同一时刻比较多对元素）
- 按主要操作：比较排序和基数排序
  - 比较排序  用比较的方法，如插入排序、交换排序、选择排序、归并排序
  - 基数排序  不比较元素的大小，仅仅根据元素本身的取值确定其有序位置
- 按辅助空间：原地排序和非原地排序
  - 原地排序  辅助空间用量为O(1)的排序方法（所占的辅助空间与参加排序的数据量大小无关）
  - 非原地排序  辅助空间用量超过O(1)的排序方法
- 按稳定性：稳定排序和非稳定排序（排序的稳定性只对结构类型数据排序有意义）
  - 稳定排序  能够使任何数值相等的元素，排序以后相对次序不变
  - 非稳定排序  不是稳定排序的方法
- 按自然性：自然排序和非自然排序
  - 自然排序  输入数据越有序，排序的速度越快的排序方法
  - 非自然排序  不是自然排序的方法



**重点**

内部排序、串行排序、比较排序和基数排序



**按排序依据原则**

- 插入排序：直接插入排序、折半插入排序、希尔排序
- 交换排序：冒泡排序、快速排序
- 选择排序：简单选择排序、堆排序
- 归并排序：2-路归并排序
- 基数排序

**按排序所需工作量**

- 简单的排序方法：T(n) = O(n^2^)
- 基数排序：T(n) = O(d.n)
- 先进的排序方法：T(n) = O(nlogn)

**存储结构**

```c++
#define MAXSIZE 20
typedef int KeyType; //设关键字为整型

typedef struct {  //定义每个记录（数据元素）的结构
    KeyType key;  //关键字
    InfoType otherinfo; //其他数据项
}RedType; //Record Type

typedef struct {  //定义顺序表的结构
    RedType r[MAXSIZE + 1]; //存储顺序表的向量，r[0]一般作哨兵或缓冲区
    int length; //顺序表的长度
}SqList;
```







