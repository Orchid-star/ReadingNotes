# 第8章 排序

## 8.1 基本概念

**什么是排序？**

将一组杂乱无章的数据按照一定规律顺次排列起来，即，将无序序列排成一个有序序列（由小到大或由大到小）的运算。

如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。



**排序方法的分类**

- 按数据存储介质：内部排序和外部排序
  - 内部排序  数据量不大，数据在内存，无需内外存交换数据
  - 外部排序  数据量较大，数据在外存（文件排序）
- 按比较器个数：串行排序和并行排序
  - 串行排序  单处理机（同一时刻比较一对元素）
  - 并行排序  多处理机（同一时刻比较多对元素）
- 按主要操作：比较排序和基数排序
  - 比较排序  用比较的方法，如插入排序、交换排序、选择排序、归并排序
  - 基数排序  不比较元素的大小，仅仅根据元素本身的取值确定其有序位置
- 按辅助空间：原地排序和非原地排序
  - 原地排序  辅助空间用量为O(1)的排序方法（所占的辅助空间与参加排序的数据量大小无关）
  - 非原地排序  辅助空间用量超过O(1)的排序方法
- 按稳定性：稳定排序和非稳定排序（排序的稳定性只对结构类型数据排序有意义）
  - 稳定排序  能够使任何数值相等的元素，排序以后相对次序不变
  - 非稳定排序  不是稳定排序的方法
- 按自然性：自然排序和非自然排序
  - 自然排序  输入数据越有序，排序的速度越快的排序方法
  - 非自然排序  不是自然排序的方法



**重点**

内部排序、串行排序、比较排序和基数排序



**按排序依据原则**

- 插入排序：直接插入排序、折半插入排序、希尔排序
- 交换排序：冒泡排序、快速排序
- 选择排序：简单选择排序、堆排序
- 归并排序：2-路归并排序
- 基数排序

**按排序所需工作量**

- 简单的排序方法：T(n) = O(n^2^)
- 基数排序：T(n) = O(d.n)
- 先进的排序方法：T(n) = O(nlogn)

**存储结构**

```c++
#define MAXSIZE 20
typedef int KeyType; //设关键字为整型

typedef struct {  //定义每个记录（数据元素）的结构
    KeyType key;  //关键字
    InfoType otherinfo; //其他数据项
}RedType; //Record Type

typedef struct {  //定义顺序表的结构
    RedType r[MAXSIZE + 1]; //存储顺序表的向量，r[0]一般作哨兵或缓冲区
    int length; //顺序表的长度
}SqList;
```



## 8.2 插入排序

**基本操作**

有序插入

- 在有序序列中插入一个元素，保持序列有序，有序长度不断增加
- 起初，a[0]是长度为1的子序列，然后，逐一将a[1]至a[n-1]插入到有序子序列中



**插入排序的分类**

- 直接插入排序  顺序法定位插入位置
- 二分插入排序  二分法定位插入位置
- 希尔排序  缩小增量多遍插入排序



### 8.2.1 直接插入排序算法

**直接插入排序算法**

```c++
void InsertSort(SqList &L)
{
    int i, j;
    for (i = 2; i <= L.length; ++i) {
        if (L.r[i].key < L.r[i - 1].key) {
            L.r[0] = L.r[i];
            for (j = i - 1; L.r[0].key < L.r[j].key; --j) {
                L.r[j+1] = L.r[j];
            }
            L.r[j+1] = L.r[0];
        }
    }
}
```

**时间复杂度**

- 原始数据越接近有序，排序速度越快
- 最坏情况下（输入数据是逆有序的）T~w~(n) = O(n^2^)
- 平均情况下，耗时差不多是最坏情况的一半  T~e~(n) = O(n^2^)
- 要提高查找速度
  - 减少元素的比较次数
  - 减少元素的移动次数



### 8.2.2 折半查找

```c++
void BInsertSort(SqList &L) {
    for (i = 2; i <= L.length; ++i) {
        L.r[0] = L.r[i];
        low = 1; hight = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (L.r[0].key < L.r[mid].key) high = mid - 1;
            else low = mid + 1;
        }
        for (j = 1 - 1; j >= high + 1; --j) {
            L.r[j+1] = L.r[j];
        }
        L.r[high+1] = L.r[0];
    }
}
```



### 8.2.3 希尔排序

**基本思想**

先将整个待排记录序列分割成若干个子序列，分别进行直接插入排序，待整个序列中的序列基本有序时，再对全体记录进行一次直接插入排序

**特点**

- 缩小增量
- 多遍插入排序
- 不稳定的排序

**希尔排序特点**

- 一次移动，移动位置较大，跳跃式地接近排序后的最终位置
- 最后一次只需要少量移动
- 增量序列必须是递减的，最后一个必须是1
- 增量序列应该是互质的

```c++
void ShellInsert(SqList &L, int dk) {
    for (int i = dk + 1; i <= L.length; ++i) {
        if (r[i].key < r[i - dk].key) {
            r[0] = r[i];
            for (int j = i - dk; j > 0 && (r[0].key < r[j].key); j = j - dk ) {
                r[j + dk] = r[j];
            }
            r[j+dk] = r[0];
        }
    }
}
```

