**数据结构**

- 数据的逻辑结构
  - 线性结构
    - 线性表
    - 栈（特殊线性表）
    - 队列（特殊线性表）
    - 字符串、数组、广义表
  - 非线性结构
    - 树形结构
    - 图形结构
- 数据的存储结构
  - 顺序存储
  - 链式存储
- 数据的运算：查找、排序、插入、删除、修改等



# 第7章 查找



## 7.1 查找的基本概念

**问题：在哪里找？**

查找表：查找表是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。



**问题：找什么**

根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录。

关键字：用来标识一个数据元素或记录的某个数据项的值。

- 主关键字 可唯一地标识一个记录的关键字是主关键字
- 次关键字 反之，用以识别若干记录的关键字是次关键字



**问题：查找成功了没？**

若查找表中存在一个这样的记录，则称”查找成功“，查找结果给出整个记录的信息，或指示该记录在查找表中的位置；否则称为”查找不成功“，查找结果给出空记录或空指针。



**问题：查找的目的是什么？**

对查找表经常进行的操作：

- 查询某个”特定的“数据元素是否在查找表中
- 检索某个”特定的“数据元素的各种属性
- 在查找表中插入一个数据元素
- 删除查找表中的某个数据元素



**问题：查找表怎么分类？**

- 静态查找表

  仅作查询（检索）操作的查找表

- 动态查找表

  作插入和删除操作的查找表



**问题：如何评价查找算法？**

评价指标：关键字的平均比较次数，也称**平均查找长度**



**问题：查找过程要研究的是什么**

研究查找表的各种组织方法及其查找过程的措施。

设法提高查找表的查找效率。为了提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定地约束关系





## 7.2 线性表的查找

### 7.2.1 顺序查找（线性查找）

**应用范围**

- 顺序表或线性链表表示的静态查找表
- 表内元素之间无序

**顺序表的表示**

```c++
typedef struct {
    KeyType key;  //关键字域
    ... //其他域
}ElemType;

typedef struct {
    ElemType *R; //表基址
    int length; //表长
}SSTable;

SSTable ST; //定义顺序表
```

```c++
int Search_Seq(SSTable ST, KeyType key)
{
    for (int i = ST.length; 9 >= 1; --i) { //头不存储信息
        if (ST.R[i].key == key) return i;
    }
    return 0;
}
```

**改进**

把待查关键字key存入表头（“哨兵”、“监视哨”），从后往前挨个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。

```c++
int Search_Seq(SSTable ST, KeyType type) 
{
    ST.R[0].key = key;
    for (int i = ST.length; ST.R[i].key != key; --i);
    return i;
}
```

当ST.length较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。



**性能分析**

- 时间复杂度：O(n)
- 空间复杂度：O(1)



**记录的查找概率不相等时如何提高查找效率？**

查找表存储记录原则 --- 按查找概率高低存储

- 查找概率越高，比较次数越少
- 查找概率越低，比较次数较多



**记录的查找概率无法测定时如何提高查找效率？**

按查找概率动态调整记录顺序

- 在每个记录中设一个访问频度域
- 始终保持记录按非递增有序的次序排列
- 每次查找后均将刚查到的记录直接移至表头



**顺序查找的特点**

优点：

- 算法简单，逻辑次序无要求，且不同存储结构均适用

缺点：

- ASL太长，时间效率太低







## 7.3 树表的查找





## 7.4 哈希表的查找



