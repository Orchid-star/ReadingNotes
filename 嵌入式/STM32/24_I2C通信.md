两部分内容：

- 介绍协议规则，通过软件模拟的形式实现协议
- 通过stm32的I2C外设，用硬件实现协议

I2C是同步时序，软件模拟协议也非常方便，目前也存在很多软件模拟I2C的代码，所以可以学习软件I2C和硬件I2C。哪个更方便，更有优势，可以进行对比。

先看一下串口通信。串口通信是从TX引脚向RX引脚发送数据流，数据流以字节为单位，可以组合多个字节，变成多字节的数据包传输。另外，串口通信的设计是一条发送线、一条接收线，没有时钟线的异步全双工的协议。

现在有以下需求场景，一个公司要设计一个通信协议。该公司开发出了一款芯片，可以进行AD转换、温湿度测量、姿态测量等等。在单片机中，芯片里的众多外设都是通过读写寄存器来控制运行的。寄存器本身也是存储器的一种，该芯片所有的寄存器都被分配到了一个线性的存储空间，如果想通过读写寄存器来控制硬件电路，就至少需要定义两个字节数据，一个字节是我们要读写哪个寄存器，即指定寄存器的地址，另一个字节就是这个地址下存储器存的内容。写入内容就是控制电路，读出内容就是获取电路状态，整个流程和单片机CPU操作外设的原理是一样的。问题来了，单片机读写自己的寄存器，可以直接通过内部的数据总线来实现，直接用指针即可操作。但现在一个额外的芯片模块的寄存器在单片机的外面，直接把单片机内部的数据总线拽出来把两个芯片合为一体不太现实。所以该公司需要设计这样一款通信协议，在单片机和外部模块连接少量的几根线，实现单片机读写外部模块寄存器的功能，并且具体要求：

（1）如果使用串口协议是否可行？不可以。串口的设计是一个需要两根通信线的全双工协议，但是可以发现，读写外部模块寄存器的操作流程是一种基于对话的形式进行的，在整个过程中并不需要同时进行发送或接收，这样就会导致始终存在一条信号线处于空闲状态。这就是资源的浪费。所以要求1就是**删掉一根通信线，只能在同一根线上进行发送和接收，将全双工改为半双工。**

（2）串口协议并没有一个应答机制，也就是单片机发送了一个数据，对方有没有收到，单片机是完全不了解的。所以为了安全起见，要求**增加应答机制，每发送或者接收一个字节对方都要给一个应答**。

（3）串口传输线一根线只能接一个模块，要求**一根线上能同时接多个模块，单片机可以指定和任意一个模块通信，同时单片机在跟某个模块进行通信时，其他模块不能对正常的通信产生干扰**。

（4）串口是异步的时序，也就是发送方和接收方约定的传输速率非常严格，时钟不能有过大的偏差，也不能在传输过程中单片机进中断。对于异步时钟来说，时序无法暂停。单片机一个字节发一半暂停了，接收方无法知道，依旧会按照原来约定的速率读取，这就会导致传输出错。所以异步时序的缺点就是非常依赖硬件外设的支持，必须要有USART电路才能方便的使用。如果没有USART电路的支持，串口是很难用软件来模拟的。所以**要求采样同步协议，外加一条时钟线指导对方读写**。由于存在时钟线，对传输的时间要求就不高，单片机也可以随时暂停传输去处理其他事情。因为暂停传输的同时，时钟线也暂停了，所以传输双方都能定格在暂停的时刻，过一段时间再继续不会对传输造成影响。这就是同步时序的好处。使用同步时序可以极大地降低单片机对硬件电路的依赖，即使没有硬件电路的支持，也可以很方便地用软件手动翻转电平来实现通信。异步时钟的好处是省一根时钟线节省资源，缺点是对时间要求严格，对硬件电路的依赖比较严重。同步时序反过来，优点是对时间要求不严格，对硬件电路不怎么依赖，在一些低端单片机没有硬件资源的情况下，也很容易使用软件来模拟时序，缺点是多一根时钟线。这就是同步和异步的区别。

其实通信协议是一个很灵活的设计方案，只要设计能实现项目要求、符合电路原理、性能和稳定性好，那设计就是好设计。

以上就是i2c通信协议的设计背景。

进入正题，看一下i2c通信。目标是通过通信线，实现单片机读写外挂模块寄存器的功能，其中至少要实现在指定的位置写寄存器以及在指定的位置读寄存器这两个功能。实现了读写寄存器就实现了对外挂模块的完全控制。

<img src="i2c/i2c通信简介.png" style="zoom:50%;" />

I2C，也可写为IIC。上图中第一个模块是MPU6050模块，可以进行姿态测量，使用了I2C通信协议。第二个模式是OLED模块，可以显示字符、图片等信息，也是I2C协议。第三个模块是AT24C02，存储器模块。第四个模块是DS3231模块，实时时钟模块，也是使用I2C协议。使用通用的协议对于开发者来说非常方便，通用的协议在不同的硬件上操作方法都极为相似。

第二点：I2C的标志性引脚，是两根通信线，SCL串行时钟线，SDA串行数据线。下面的四个模块图中都有SCL和SDA这两个引脚。

第五点：I2C支持挂载多设备，有两种模型，分别是一主多从（单片机作为主机，主导I2C总线的运行，挂载在I2C总线的所有外部模块都是从机，从机只有在被主机点名之后才能控制I2C总线，不能在未经允许的情况下去碰I2C总线，防止冲突。）和多主多从（比较复杂，了解即可）。

下面详细分析I2C是如何实现这些功能的。作为一个通信协议，它必须在硬件和软件上都做出规定。硬件上的规定就是电路应该如何连接，端口的输入输出模式是什么样的等。软件上的规定就是，时序是怎么定义的，字节如何传输，高位先行还是低位先行，一个完整的时序由哪些部分构成等。硬件和规定和软件的规定配合起来就是一个完整的通信协议。

<img src="i2c/i2c的硬件电路.png" style="zoom:50%;" />

上面ppt中左边的图是i2c的一个典型电路模型，这是一个一主多从的模型，左边CPU是单片机作为总线的主机。主机的权力很大，包括对SCL线的完全控制，任何时候都是主机完全掌控SCL线，另外在空闲状态下，主机可以主动发起对SDA的控制，只有从机发送数据和从机应答的时候，主机才会转交SDA的控制权给从机。下方是众多从机，这些从机可以是姿态传感器、OLED、存储器、时钟模块等。从机的权利小，对于SCL时钟线，在任何时刻都只能被动的读取，从机不允许控制SCL线。对于SDA数据线，从机不允许主动发起对SDA的控制，只有在主机发送读取从机的命令或从机应答时，从机才能短暂地取得SDA的控制权。这些是一主多从模型中协议的规定。

首先忽略上部的两个电阻R，那如何规定每个设备SCL和SDA的输出输出模式？SCL好规定，因为现在是一主多从，主机拥有SCL的绝对控制权，所以主机的SCL可以配置成推挽输出，所有从机的SCL都配置成浮空输入或者上拉输入，数据流向是主机发送、所有从机接收。而SDA线比较麻烦，因为是半双工的协议，所以主机的SDA在发送的时候是输出，在接收的时候是输入。通用从机的SDA也会在输入和输出之间反复切换。如果能协调好输入输出的切换时机，其实也没问题，但这样做，如果总线时序没协调好，极有可能发生两个引脚同时处于输出的状态。如果此时正好一个输出高电平一个输出低电平，则该状态就是电源短路。这种状态是要极力避免的。所以为了避免总线没协调好导致电源短路的问题，I2C的设计是禁止所有设备输出强上拉的高电平，采用外置弱上拉电阻加开漏输出的电路结构，所以有了ppt中第2条的规定。所有的设备，包括CPU和被控IC，它们引脚的内部结构都是上面ppt右图所示，左边是SCL的结构（图中SCLK就是SCL），右边是SDA的结构（图中DATA就是SDA）。首先引脚的信号进来，都可以通过数据缓冲器或这施密特触发器进行输入，因为输入多设备没有任何影响，所以任何设备在任何时刻都是可以输入的。但是在输出的部分采用的是开漏输出的配置。正常的推挽输出是（图略）：上面一个开关管接到正极，下面一个开关管接到负极，上面导通输出高电平，下面导通输出低电平，因为是通过开关管直接接到正极和负极的，所以是强上拉和强下拉的模式。而开漏输出，是去掉强上拉的开关管，输出低电平时下管导通，是强下拉，输出高电平时下管断开，但是没有上管，此时引脚处于浮空的状态，这就是开漏输出。右图就是开漏输出，SCLK输出低电平时开关管导通，引脚直接接地，是强下拉，输出高电平开关管断开，SCLK引脚什么都不接，处于浮空状态，这样所有的设备都只能输出低电平而不能输出高电平。为了避免高电平造成的引脚浮空，这时就需要在SCL和SDA各外置一个上拉电阻，通过电阻拉到高电平，所以是一个弱上拉。用弹簧和杆子的模型解释就是：SCL和SDA就是一根杆子，为了防止有人向上推杆子以及有人向下拉杆子造成冲突，所以规定所有的人不允许向上推杆子，只能选择向下拉或者放手，然后再外置一根弹簧向上拉，想要输出低电平就往下拽，弹簧被拉升，杆子处于低电平；要输出高电平就放手，杆子在弹簧拉力下回到高电平。这就是弱上拉的高电平，但是完全不影响数据传输。这样做的好处是完全杜绝了电源短路的现象，保证电路的安全，并且避免了引脚模式频繁地切换，开漏加弱上拉的模式同时键入了输入和输出的功能。并且，还会有一个“线与”的现象，就是只要有任意一个或多个设备输出了低电平，总线就处于低电平，只有所有设备都输出高电平，总线才处于高电平，I2C可以利用这个电路特性执行多主机模式下的时钟同步和总线仲裁。所以SCL虽然在一主多从模式下可以用推挽输出，但它仍然采用了开漏加上拉输出的模式。

以上是I2C的硬件电路设计。下面开始分析软件方面，即时序的设计。

首先学习一下I2C规定的一些时序基本单元。

<img src="ppt2/I2C时序基本单元1.png" style="zoom:50%;" />

首先是起始条件，它是指SCL高电平期间，SDA从高电平切换到低电平。看左下角图，在I2C总线处于空闲状态时，SCL和SDA都处于高电平状态，也就是没有任何一个设备去碰SCL和SDA，SCL和SDA由外挂的上拉电阻拉高至高电平，总线处于平静的高电平状态。当主机需要进行数据收发时，首先就要打破总线的宁静，产生一个起始条件。这个起始条件就是SCL处于高电平不去动它，然后将SDA拽下来产生一个下降沿。当从机捕获到这个SCL高电平、SDA下降沿信号时，就会进行自身的复位，等待主机的召唤。然后在SDA下降沿之后，主机要把SCL拽下来。拽下SCL，一方面是占用这个总线，另一方面也是为了方便我们基本单元的拼接，就是我们之后会保证除了起始和终止条件，每个时序单元的SCL都是以低电平开始，低电平结束，这样这些单元拼接起来，SCL才能续得上。

继续看，终止条件是SCL高电平期间，SDA从低电平切换到高电平，即SCL先放手回弹到高电平，SDA再放手回弹到高电平产生一个上升沿，该上升沿触发终止条件。同时终止条件之后，SCL和SDA都是高电平，回归到最初的平静状态。这个起始条件和终止条件就类似串口时序里的起始位和停止位。一个完整的数据帧，总是以起始条件开始、终止条件结束，并且起始和终止都是由主机产生的，从机不允许产生起始和终止。所以在总线空闲状态时，从机必须始终双手放开，不允许主动跳出来去碰总线。如果允许的话，就是多主机模型。

在起始条件之后，就可以紧跟着发送一个字节的时序单元。

<img src="ppt2/I2C时序基本单元2.png" style="zoom:50%;" />

如何发送一个字节呢？就是SCL低电平期间，主机将数据位依次放到SDA线上（高位先行），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节。如左图，第一个字节，也必须是主机发送的。主机如何发送呢，就是最开始SCL低电平，主机如果想发送0，就拉低SDA到低电平，如果想发送1，就放手，SDA回弹到高电平。在SCL低电平期间，允许改变SDA的电平。当这一位放好之后，主机就松手时钟线，SCL回弹到高电平。在高电平期间，是从机读取SDA的时候，所以高电平期间，SDA不允许变化。SCL处于高电平之后，从机需要尽快地读取SDA，一般是在上升沿时刻从机就已经读取完成了。因为时钟是主机控制的，从机并不知道什么时候就会产生下降沿，所以从机在上升沿时就会立刻将数据读走。主机放手SCL一段时间后，就可以继续拉低SCL，传输下一位了。主机也需要在SCL下降沿之后尽快把数据放到SDA上。但是主机有时钟的主导权，所以主机并不需要那么着急，只需要在低电平的任意时刻把数据放在SDA上就行了。数据放完之后，主机再松手SCL，SCL高电平，从机读取一位。就这样的流程，主机拉低SCL把数据放到SDA上，主机松开SCL，从机读取SDA数据。在SCL的同步下，依次进行主机发送和从机接收，循环8次，就发送了8位数据，即一个字节。另外注意是高位先行，所以依次是B7-B0，这个和串口不一样，串口是低位先行，I2C是高位先行。另外，由于有时钟线的同步，如果主机一个字节发送一半，突然进中断，不操作SCL和SDA了，则时序就会在中断的位置不断拉长，SCL和SDA电平都暂停变化，传输完全暂停，等中断结束后，主机回来继续操作，传输仍然不会出问题，这就是同步时序的好处。最后，由于整个时序是主机发送一个字节，所以SCL和SDA全程由主机掌控，从机只能被动读取，这就是发送一个字节的时序。

下面再看接收一个字节的时序。

<img src="ppt2/I2C时序基本单元3.png" style="zoom:50%;" />

接收一个字节的基本流程是，SCL低电平期间，从机将数据位依次放到SDA上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据位变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）。

释放SDA其实就相当于切换成输入模式，或者这样理解，所有设备包括主机都始终处于输入模式，当主机需要发送的时候，就可以主动去拉低SDA，而主机处于接收的时候就必须释放SDA，不要去动它，以免影响别人发送。因为总线是线与的特征，任何设备拉低了，总线就是低电平。如果接收时还拽着SDA不放手，那别人无论发什么数据，总线始终都是低电平。从流程上看，接收一个字节和发送一个字节是非常相似的，区别就是：发送一个字节是低电平主机放数据，高电平从机读数据；而接收一个字节是，低电平从机放数据，高电平主机读数据。上右图中，实线表示主机控制的电平，虚线表示从机控制的电平。SCL全程由主机控制，SDA主机在接收前要释放，交由从机控制。之后，因为SCL时钟是由主机控制的，所以从机的数据变化基本上都是贴着SCL下降沿进行的，而主机可以在SCL高电平的任意时刻读取。这就是接收一个字节的时序。

继续看最后两个基本单元，即应答机制的设计。

<img src="ppt2/I2C时序基本单元4.png" style="zoom:50%;" />

首先，应答机制分为发送应答和接收应答。它们的时序分别和发送一个字节、接收一个字节的其中一位是相同的，可以简单地理解为发送一位和接收一位，这一位就用来作为应答。

发送应答，主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答。接收应答，主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收前需要释放SDA）。意思是，我们在调用发送一个字节之后，就要紧跟着调用接收应答的时序，用来判断从机有没有收到刚才给它的数据。如果从机收到了，那么在应答位这里，主机释放SDA的时候，从机就应该立刻把SDA拉下来，然后在SCL高电平期间，主机读取应答位，如果应答位为0，就说明从机确实收到了。同理，在接收一个字节之后，我们也要给从机发送一个应答位，发送应答位的目的是告诉从机，你是不是还要继续发。如果从机发送一个数据后，得到了主机的应答，那从机就还会继续发送，如果从机没得到主机的应答，则从机认为主机不需要数据，这是从机就会释放SDA，交出SDA的控制权，防止干扰主机之后的操作。这就是应答位的执行逻辑。

至此，I2C的6块拼图集齐。接下来拼接这些基本单元，组成一个完整的数据帧。I2C的完整时序，主要有指定地址写，当前地址读和指定地址读3种。