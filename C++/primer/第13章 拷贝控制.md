# 第13章 拷贝控制

类通过部分特殊成员函数控制对象拷贝、赋值、移动或销毁：

- 拷贝构造函数
- 移动构造函数
- 拷贝赋值运算符
- 移动赋值运算符
- 析构函数

拷贝和移动构造函数定义用同类型的另一个对象初始化本对象的行为；

拷贝和移动赋值运算符定义将一个对象赋予同类型的另一个对象时的行为。

**拷贝控制**：对象拷贝、移动、赋值、销毁，统称拷贝控制



## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

***拷贝构造函数：***

第一个参数是自身类类型的引用、且其他所有额外参数都有默认值的构造函数，称为拷贝构造函数。

```c++
class Foo {
    public:
    Foo(); //默认构造函数
    Foo(const Foo &);  //拷贝构造函数，第一个参数必须是自身类型引用
};
```

**合成拷贝构造函数**：

没有为一个类定义拷贝构造函数时由编译器定义的拷贝构造函数。（只要没有拷贝构造函数，编译器就会生成；而合成默认构造函数只有没有任何构造函数时编译器才会生成。

合成的拷贝构造函数会将非static成员逐个拷贝到正在创建的对象中。

**拷贝初始化与直接初始化**：

拷贝初始化最常发生在使用赋值运算符`=`的场景下，如`CA a = b`，以及函数调用过程中具有非引用类型的参数或返回值的场景下。

直接初始化由编译器根据函数匹配规则选择最优的构造函数；拷贝初始化要求编译器通过拷贝构造函数或移动构造函数将右侧运算对象拷贝到正在创建的对象中。

**拷贝构造函数为什么必须是引用类型？**

如果参数不是引用类型，则调用无法成功----为了调用拷贝，必须先拷贝实参，为了拷贝实参，又需调用拷贝构造，所以无法实现。

**拷贝初始化的限制**：

```c++
vector<int> v1(10); //正确，直接初始化
vector<int> v2 = 10;  //错误，接收大小i参数的构造函数是explicit
```



### 13.1.2 拷贝赋值运算符

如果类未定义拷贝运算符，编译器会合成。

**重载运算符**：

本质上是函数，其名字由operator关键字后接运算符组成。如：赋值运算符是一个名为operator=的函数。类似于其他函数，运算符函数同样有一个返回类型和一个参数列表。

运算符左侧对象绑定到运算符函数内this指针，右侧对象作为右侧参数。

*拷贝赋值运算符接收一个与其所在类相同的参数* ：

```c++
class Foo {
    public:
    Foo & operator=(const Foo &); //赋值运算符
};
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用（左值，与内置类型的赋值保持一致）

**合成拷贝赋值运算符**：

非static成员赋予左侧对象的对应成员。



### 13.1.3 析构函数

析构函数：释放对象使用的资源，并销毁对象的非static数据成员。

对象成员初始化在构造函数执行前完成，对象的销毁在析构函数执行之后。

**合成析构函数**：

合成析构函数的函数体为空。



### 13.1.4 三五法则

***需要析构函数的类也需要拷贝和赋值操作！！！***

如果一个类需要一个析构函数，几乎可以肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

***需要拷贝操作的类也需要赋值操作，反之亦然！！！***

***总结：拷贝构造函数和拷贝赋值运算符必定同时出现！***



### 13.1.5 使用=default

通过将拷贝控制成员（拷贝构造、拷贝赋值、析构）定义为=default来显示地要求编译器生成合成的版本。

```c++
class Sales_data {
    public:
    Sales_data() = default;  //内联
    Sales_data(const Sales_data&) = default;  //内联
    Sales_data &operator=(const Sales_data *);
    ~Sales_data() = default;  //内联
};
Sales_data &Sales_data::operator=(const Sales_data *) = default;  //非内联
```



### 13.1.6 阻止拷贝=delete

iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。

办法：将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**。

语法：在函数的参数列表后面加上=delete来定义删除。

```c++
struct NoCopy {
    NoCopy() = default;  //合成
    NoCopy(const NoCopy &) = delete;  //阻止拷贝
    NoCopy &operator=(cosnt NoCopy &) = delete;  //阻止赋值
    ~NoCopy() = default;
};
```

***可以对任何函数指定=delete，但只能对合成的默认构造函数和拷贝控制成员使用=defalult !!!***

***析构函数不能是删除的成员。***

当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

**private拷贝控制**：

新标准之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝（无需定义）：

```c++
class PrivateCopy {
    PrivateCopy(const PrivateCopy &);
    PrivateCopy &operator=(const PrivateCopy &);
};
```

声明但不定义一个成员函数是合法的。试图访问一个未定义的成员将导致一个链接时错误。

优先使用=delete阻止拷贝，不推荐private拷贝控制。



## 13.2 拷贝控制和资源管理

类的拷贝语义有两种：是类的行为看起来像一个值（如string）或指针（如shared_ptr）。

### 13.2.1 行为像值的类

```c++
class HasPtr {
public:
    HasPtr(const string &s = string()):ps(new string(s)), i(0) {}
    HasPtr(const HasPtr &p):ps(new string(*p.ps)), i(p.i) {}
    HasPtr &operator=(const HasPtr &);
    ~HasPtr() {delete ps;}
private:
    string *ps;
    int i;
};

HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps); //必须先拷贝
    delete ps;  //拷贝完再释放指针，在自身给自身赋值时如果是先释放再拷贝是行不通的
    ps = newp;
    i = rhs.i;
    return *this;
}
```

### 13.2.2 行为像指针的类

***引用计数实例！！！***

```c++
class HasPtr {
public:
    HasPtr(const string &s = string()) : ps(new string(s)), i(0), use(new std::size_t(1)) {}
    HasPtr(const HasPtr &p) : ps(p.ps), i(p.i), use(p.use) { ++*use;}
    HasPtr &operator=(const HasPtr &);
    ~HasPtr();
private:
    string *ps;
    int i;
    std::size_t *use;
};

HAsPtr::~HasPtr()
{
    if (--*use == 0) {
        delete ps;
        delete use;
    }
}

HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use;
    if (--*use == 0) {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;  //自身给自身赋值存在问题？
}
```



## 13.3 交换操作swap

管理资源的类通常还定义一个名为swap的函数，对于那些与重排元素顺序的算法一起使用的类，定义swap非常重要，是一种非常重要的优化手段。

要注意调用的是自定义的swap还是标准库std::swap（标准库swap一次拷贝两次赋值。

**编写自定义swap函数交换指针：**

```c++
class HasPtr {
    friend void swap(HasPtr &, HasPtr &);
};
inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    std::swap(lhs.ps, rhs.ps);
    std::swap(lhs.i, rhs.i);
}
```

**赋值运算符中使用swap：**

定义swap的类通常用swap来定义他们的赋值运算符，使用名为***拷贝并交换*** 技术。

```c++
HasPtr &operator=(HasPtr rhs) //注意：值传递
{
    swap(*this, rhs);
    return *this;
}
```

***重要！！！***

区分拷贝构造与拷贝赋值运算符的场景：拷贝构造在定义变量时调用，如`CA a = b;`调用的是拷贝构造而非拷贝赋值运算符；拷贝赋值运算符将已有的对象值赋给已有的另一个对象，注意是已有的对象，如`CA a; a = b;`调用的是拷贝赋值运算符。所以，拷贝构造函数的参数必须是自身的引用，而拷贝赋值运算符没有必须是自身引用。



## 13.5 动态内存管理类

