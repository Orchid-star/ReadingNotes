# 第15章 面向对象程序设计

面向对象程序设计的三个基本概念：**数据抽象、继承、动态绑定**（对应封装、继承、多态）。

继承与动态绑定：定义与其他类相似但不完全相同的新类，且在使用这些彼此相似的类编程时可以一定程度上忽略掉它们的区别。

面向对象的程序设计（OOP）适用于存在着相互关联但是有细微差别的概念。



## 15.1 OOP概述

**面向对象程序设计**（object-oriented programming）核心思想：**数据抽象、继承、动态绑定**。

- 通过使用数据抽象，可以将类的接口于实现分离
- 使用继承，可以定义相似的类型并对相似关系进行建模
- 使用动态绑定，可以一定程度上忽略相似类型的差别，以统一的方式使用它们的对象

**继承**：通过继承联系在一起的类构成层次关系，即基类、派生类。基类负责定义层次关系中所有类共同拥有的成员，派生类定义各自特有的成员。

**虚函数**：基类希望派生类各自定义适合自身的版本时，将相关函数声明为虚函数。

**类派生列表**：明确指出从哪些基类继承而来，形式是：首先是冒号，后面紧跟以逗号分隔的、带有访问说明符的基类列表。大多数类都只继承自一个类，这种形式称为 *单继承*。

**动态绑定**：又称**运行时绑定**，指函数的运行版本由实参决定，在运行时选择函数的版本。



## 15.2 定义基类和派生类

### 15.2.1 定义基类

***Note:*** 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此！

**成员函数与继承**

派生类可以继承基类的成员，但对基类声明为virtual的函数，派生类需要对其提供自己的新定义以**覆盖（override）**从基类继承而来的旧定义。

基类必须将其希望派生类进行覆盖的函数（定义为虚函数）以及直接继承、不要改变的函数区分开来。**当使用指针或者引用调用虚函数时，根据引用或指针绑定对象的类型，动态绑定要执行的版本**。可能执行基类的版本，也可能执行派生类的版本。

任何构造函数之外的非静态函数都可以是虚函数，virtual只能出现在声明语句前而不能用于类外部的函数定义。基类中声明的虚函数，在派生类中隐式地也是虚函数。

非虚函数的解析过程发生在编译时而非运行时。

**访问控制与继承protected**：派生类有权访问但其他用户禁止访问。



### 15.2.2 定义派生类

**派生类构造函数**：派生类不能直接初始化从基类继承而来的成员，必须使用基类的构造函数来初始化它的基类部分。每个类控制它自己的成员初始化过程。**首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员**。

**遵循基类的接口**：派生类应该遵循基类的接口，所以派生类不能直接初始化基类的成员（尽管从语法上可以在派生类构造函数体内给它的公有或受保护的基类成员赋值）

**继承与静态成员**：基类的静态成员在整个继承体系中只存在该成员唯一定义。静态成员遵循统一的访问控制规则（即基类的private静态成员，派生类无法访问；可访问的静态成员即可通过基类、也可通过派生类使用）。

**派生类的声明**：形如`class Buil_quote`，不需要加上类派生类别。一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。

**被用作基类的类**：必须已经定义而非仅仅声明（解释了类头文件中为什么要添加父类的头文件），因此一个类不能派生它自身。每个派生类包含它的直接基类的子对象以及每个间接基类的子对象。

**禁止继承final**：不希望其他类继承，可以使用final关键字，如`class NoDrived final { };`



### 15.2.3 类型转换与继承

通常情况下，指针或引用的类型应与对象的类型一致，但存在继承关系的类是一个重要的例外：可以将基类的指针或引用绑定到派生类对象上，这有一层**极为重要的含义：并不清楚该引用或指针所绑定对象的真实类型。**

**静态类型**：表达式的静态类型在编译时已知，是变量声明时的类型或表达式生成的类型。

**动态类型**：变量或表达式表达的**内存中的对象的类型**，直到运行时才可知。

综上：基类的指针或引用的静态类型可能与其动态类型不一致。

因为每个派生类对象包含一个基类部分，所以存在派生类向基类的类型转换，反之不行。

**dynamic_cast**：如果基类中含有虚函数，可以使用dynamic_cast请求一个类型转换，运行时会执行安全检查

**static_cast**：如果已知某个基类向派生类的转换是安全的，可以使用static_cast轻质覆盖编译器的检查工作。

总结：基类指针可以直接使用派生类地址赋值（是自动类型转换或称之为隐式类型转换，不使用强制类型转换），反之派生类型指针用基类类型地址赋值，需要用dynamic_cast或static_cast进行类型转换，两者的区别是dynamic_cast会在运行时进行安全检查（转换失败返回nullptr），static_cast不会，static_cast要人为确保基类向派生类的转换是安全的。



## 15.3 虚函数

所有虚函数必须有定义，不管是否被用到，因为编译器也无法确定会使用哪个虚函数。

被调用的虚函数取决于被绑定到引用或指针上的动态类型。

**引用或指针的静态类型和动态类型可能不同是C++语言支持多态性的根本所在。当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，对非虚函数的调用以及通过对象进行的函数调用（不论是否为虚函数）在编译时绑定。**

基类中的虚函数，在所有派生类中依旧是虚函数。

**override**：派生类中与基类虚函数同名但形参列表不同的函数合法但无法覆盖基类虚函数。可以使用override标记要覆盖的虚函数，如果没有覆盖已存在虚函数编辑器将报错。

**final**：形参列表之后标记函数为final将不允许任何尝试覆盖该函数的操作

**虚函数与默认实参**：对具有默认实参的虚函数，假设基类中虚函数与派生类中虚函数的默认实参不同，通过指针或引用调用该函数时即使运行的是派生类的虚函数版本，但使用的依旧是基类虚函数的默认实参。所以基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**：使用作用域，形如*p_base->CBase::net_price()*。回避虚函数的默认机制一般发生在派生类的虚函数调用它覆盖的基类的虚函数版本。（不加基类作用域调用会造成递归）。



## 15.4 抽象基类

为纯虚函数在类外部提供定义实际是允许的。

**抽象基类**：含有纯虚函数的类，抽象基类不能实例化。



## 15.5 访问控制与继承

重要性质：派生类的成员或友元只能通过派生类对象访问基类的受保护成员，派生类对一个基类对象中的受保护成员没有任何访问特权。

```c++
class Base {
  protected:
    int pro_mem;
};
class Sneaky : public Base {
    friend void clobber(Sneaky &); //能访问Sneaky::prot_mem
    friend void clobber(Base &); //不可访问Base::pro_mem
};
```

**公有、私有、受保护继承**

- 派生类对基类成员的访问与派生访问说明符无关，置于基类中的访问说明符有关
- 派生访问说明符控制派生类（以及派生类的派生类等）用户对基类成员的访问
- 派生访问说明符控制继承自派生类的新类对基类成员的访问（公有继承时遵循原有的访问说明符，私有继承时成员全部变私有，保护继承时成员全部变保护）

**关键概念：类的设计者与受保护的成员**

不考虑继承：类有两种不同的用户，分别是普通用户和类的实现者。

考虑继承：出现第三种用户，即派生类。

**友元与继承**

友元关系不能传递，也不能继承。友元不能随意访问基类成员。

**使用using改变个别成员的可访问性**

```c++
class Base {
public:
    std::size_t size() const { return n; }
protected:
    std::size_t n;
};

class Derived1 : private Base {
    //私有继承，Base的public成员和protect成员都将成为Derived1的私有成员,Derived对象无法访问，子类无法访问
};

class Derived2 : private Base {
public:
    using Base::size; //改变Base::size的私有属性，变成公有，外部可访问
protected:
    using Base::n; //改变继承得到的n的属性，子类可继承
};
```

派生类只能为那些它可访问的名字提供using声明。

总结：公有、私有和受保护的继承不影响子类对基类成员的访问，实际影响的是基类中子类可访问的公有和受保护的成员在子类中的保护级别。如果公有继承，基类的public成员在子类中依旧是public，protected成员在子类中依旧是protected；如果是私有继承，基类的public和protected成员在子类中是private；如果是受保护的继承，基类的public和protected成员在子类中是protected。因此继承的保护级别影响的是子类用户以及子类的派生类们对子类成员的访问。

**默认的继承保护级别**

struct默认public继承，class默认private继承。

struct和class唯一的差别就是默认成员访问说明符及派生访问说明符的差异。



## 15.6 继承中的类作用域

基类作用域包含派生类作用域（解释了派生类可访问基类成员的原因）。

编译时的名字查找由静态类型决定，静态类型决定了对象哪些成员是可见的（即使是虚函数），所以静态类型决定了哪些成员可访问。

 派生作用域将隐藏基类作用域的同名名字，可通过作用域运算符使用被隐藏的成员。除虚函数外，不推荐重定义基类中的名字。

**关键概念：名字查找与继承**

函数调用的解析过程如下：首先确定静态类型，在对象静态类型对应的类中查找要调用的函数，找不到则在直接基类查找直到继承链顶端，若仍找不到，则编译器报错。找到了进行常规类型检查，若调用合法，编译器再根据是否是虚函数产生不同的代码：若是虚函数且通过引用或指针调用，则编译器产生的代码将在运行时根据对象的动态类型确定运行虚函数的哪一个版本；若不是虚函数，编辑器则产生一个常规函数调用。

**重载（overload）与覆盖（override）的区别？**

重载：同一作用域下的同名函数（形参列表不一致）称为重载函数。内层作用域的对象会隐藏外层作用域的对象（包括普通变量和函数，哪怕函数的形参列表不一致），所以内部作用域的函数不会重载声明在外层作用域的函数。

覆盖：针对虚函数而言，发生在派生作用域与基类作用域之间，是派生类对基类虚函数的重新实现，虚函数在基类和派生类中返回类型、函数名、形参列表完全一致。如果通过引用或指针调用，会根据对象的动态类型来确定运行虚函数的哪个版本，

```c++
struct Base {
    int mem_fcn();
};
struct Derived : Base {
    int mem_fcn(int);
};
Derived d;
Base b;
d.mem_fcn(); //error
d.Base::memfuc(); //正确
```

**如何理解查找先于类型检查？**

以上面程序为例，`d.mem_fcn()`先在`d`的作用域`Derived`内查找，`Derived`内确实定义了一个`mem_fcn`，所以编译器不再继续查找，进行类型检查时形参列表不一致，所以报错。

**基类多个重载函数，子类定义了同名函数导致基类所有重载函数被屏蔽，如何处理？使用子类使用using或调用时指定基类作用域**

```c++
class Base {
public:
    void func(int val) { std::cout << "value:" << val << std::endl; };
    void func(std::string str) { std::cout << "string:" << str << std::endl; };
    virtual void func() { std::cout << "base func" << std::endl; }
};

class Derived : public Base {
public:
    using Base::func;
    void func() { std::cout << "Derived func" << std::endl; }
};

int main()
{
    Derived d;
    d.Base::func(2);
    d.Base::func("main call");
    d.func(2); //因为using Base::func，所以此处合法
    d.func("main call"); //因为using Base::func，所以此处合法
    d.func();
}
```



## 15.7 拷贝函数与拷贝控制



### 15.7.1 虚析构函数

通常应该为基类定义一个虚析构函数（哪怕只是定义空的函数体）。

**如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。**



### 15.7.2 合成拷贝控制与继承



待继续