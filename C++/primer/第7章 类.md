# 第7章 类

类的作用：反应待解决问题中的各种概念的自定义数据类型

***类的基本思想！！！***

- **数据抽象**：一种依赖于**接口**和**实现**分离的编程以及设计技术
- **封装**：实现类的接口与实现的分离，隐藏实现细节

数据抽象定义接口，封装实现接口。

**抽象数据类型**：封装（隐藏）了实现细节的数据接口



## 7.1 定义抽象数据类型

成员函数通过调用`this`的额外的隐式参数来访问调用它的对象

this是一个常量指针



***引入const的成员函数！***

这里解释为什么成员函数形参列表后有时添加const的原因。首先明确是为不改变类成员变量的函数后添加const。

使用指针访问一个对象而没有改变这个对象意图的时候，使用底层const防止对象被意外篡改是一个好的编程习惯。类对象调用成员函数时，隐式使用了形参this，是一个顶层const（即ClassName * this const，this本身是常量）。所以在我们不修改类成员变量（代表着不修改类对象）的时候，基于上述的编程好习惯，我们应该使用一个底层const的this指针来访问类对象成员，所以在相应成员函数形参列表后添加const，表示隐式使用底层const的this，而不是默认的顶层const。这种成员函数称作***常量成员函数***。

注意：h文件中的声明与cpp文件中的定义都需要形参列表后加const.

因此，常量对象只能调用常量成员函数。

```c++
class CA1 {
public:
	CA1() {}

	int func1() {
		return this->m_a; //此处的this是 CA1 *
	}

	int func1() const {
		return this->m_a; //此处的this是 const CA1 *
	}

private:
	int m_a;
};
```



编译器首先编译类的声明，然后才编译成员函数体，这是函数体类可以随意使用类中的其他成员而无需在意成员出现的次序的原因。



### 7.1.4 构造函数

**构造函数**：初始化类对象数据成员的一个或若干个的成员函数（即重载）

构造函数不能被声明为const，且创建类的一个const对象时，直到构造函数完成初始化过程对象才真正获得常量属性。

**默认构造函数**：没有显示定义类的构造函数时，由编译器隐式定义默认构造函数，也叫合成的默认构造函数。

默认构造函数没有实参，且只有在类内没有声明任何构造函数时，编译器才会自动生成默认构造函数（除非使用`= default`要求编译器添加默认构造函数）。自定义默认构造函数即定义一个没有实参的构造函数。



**类内初始值**：成员变量定义时就赋了值，叫内类初始值，如:

```c++
struct CA {
    CA() = default;  //注意使用合成默认构造函数是内置类型都使用了类内初始值，否则值未初始化
    int m_a = 0;  //提供了类内初始值
};
```



## 7.2 访问控制与封装

**访问说明符**：`public、private、protected`用于加强类的封装性（封装即隐藏细节）

**class和struct的区别**：唯一区别是默认访问权限不同，class第一个访问说明符前定义的成员是private的，而struct第一个访问说明符前定义的成员默认是public的。



### 7.2.1 友元

**友元**：通过添加`friend`声明获取类非共有成员访问权限的其他类或函数。

友元一般定义在第一个类型声明符之前，事实上友元声明在类内出现的位置不限，不受区域访问控制级别的越苏。



***封装的益处！！***

- 确保用户代码不会无意间破坏封装对象的状态
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码





## 7.3 类成员再探

类内定义的自定义类型或类型别名存在访问限制，可以说pubilc或private中的一种。

类内定义的自定义类型或类型别名必须先定义后使用，因此类型成员通常出现在类开始的地方。

**内联函数**：

- 定义在类内部的成员函数（即h文件中就包含定义）自动是inline的
- 定义在类外部的函数声明和定义都可加inline，建议只在类外部定义的地方添加inline，更易理解

**可变数据成员**：类内添加`mutable`声明的成员永远不会是const，即使类对象是const，也能修改该成员

```c++
class CA {
private:
    mutable int m_a; //即使定义了一个const CA的对象，其m_a也是可修改的
};
```

***C++11新标准鼓励默认值声明成一个类内初始值！***

```c++
class Window_mhr {
    private:
    std::vector<Screen> screens{24,80,' '}; //鼓励这种方式
};
```

返回`*this`能够连续调用。



### 7.3.3 类类型

**不完全类型**：只知道是一个类但不知道具体的定义（即包含哪些数据成员），称为不完全类型

不完全类型可以定义相应的指针或引用，或声明以不完全类型作为参数或返回类型的函数。



## 7.4 类的作用域

类作用域内包含：

（1）普通的数据成员和函数 -- 类外只能由对象或对象的引用、指针通过成员访问运算符访问

（2）类类型成员（即类内定义的新的数据类型） -- 类外使用作用域运算符访问

注意：

```c++
/*
对于形参：ScrreenIndex是Window_mgr作用域内的类类型，此时编译器已知当前作用域为Window_mgr,所以不必写成Windoe_mgr::ScreenIndex i
对于返回类型：返回类型出现在类名之前，所以位于Window_mgr作用域外，所以需要单独添加作用域
*/
Window_mgr::ScreenIndex Window_mgr::clear(ScreenIndex i) 
{
    //...
}
```

### 7.4.1 名字查找与类的作用域

类的定义分两步：

（1）编译成员的声明

（2）直到类全部可见后编译函数体

这两步是成员函数可以使用类内定义的任何名字的原因。

***类作用域内，在类作用域外查找！***

类内名字的查找优先从类作用域内查找，找不到再到类外的全局作用域查找。`::`作用域访问符可以屏蔽作用域内的查找，直接到类外作用域查找。（即使类外作用域没有对应名字而类内有名字，也不会使用类内的名字，而是直接报错）

```c++
int m_a = 0;

class CA {
public:
    void func();
private:
    int m_a;
};
void CA::func()
{
    m_a; //CA::m_a
    ::m_a; //全局
}
```



## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显示地初始化成员，则该成员i将在构造函数执行前默认初始化。

构造函数初始值必不可少地情况包括：常量、引用、未提供默认构造函数地类类型。

***成员初始化顺序***：

成员的初始化顺序与它们在类定义中出现地顺序一致，构造函数初始值列表中初始值地前后位置关系不会影响实际地初始化顺序。

***默认实参与构造函数***：

如果一个构造函数为所有参数都提供了默认实参，则实际上也定义了默认构造函数。



### 7.5.2 委托构造函数

一个类包含若干个构造函数，类的构造函数在初始值列表位置调用其他构造函数，被调用地构造函数就是*委托构造函数*。



### 7.5.4 隐式的类类型转换

***能通过一个实参调用的构造函数定义了一条从构造函数的参数向类类型隐式转换的规则！！！***

***通过explict关键字声明构造函数，抑制构造函数定义的隐式转换！！！***

***explict构造函数只能用于直接初始化，不能用于拷贝形式的初始化（如使用=的值初始化）！！！***

```c++
class CA {
public:
    explict CA(int var) {};
};
int main()
{
    CA a = 0; //错误，不允许（因为声明了explict，否则利用隐式转换是合法的）
}
```



### 7.5.5 聚合类

满足以下条件的就是聚合类：

- 所有成员public
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类和virtual函数

```c++
struct Data {
    int ival;
    string s;
};
```

可以提供一个花括号括起来的成员初始值列表，初始值的顺序必须与声明顺序一致。

```c++
Data = {2, "Anna"};
```



## 7.6 类的静态成员

类的静态成员与类本身相关，独立于所有类的对象。

类的静态成员一般情况下在类内声明，在类外定义；在类内定义必须是常量表达式constexpr。

**静态成员与普通成员的区别**：静态数据成员可以是不完全类型（同指针、引用），普通成员必须是完全类型。

```c++
class Bar {
private:
    static Bar mem1; //合法：静态成员可以是不完全类型
    Bar *mem2; //合法，指针成员可以是不完全类型
    Bar mem3;  //错误，数据成员必须是完全类型
};
```

