# 第4章 表达式

C++定义了运算符作用于内置类型运算对象时所执行的操作；

C++允许由用户自定义运算符作用于类对象时所执行的操作（重载运算符）。

**表达式**：由运算对象和运算符组成的式子。对表达式求值会得到一个结果，最简单的表达式是字面值和变量，求值结果就是自身。



## 4.1 基础

### 4.1.1 基本概念

运算符：一元、二元、三元（根据上下文决定）；函数调用也是一种特殊的额运算符，对运算对象的数量没有限制。

***重载运算符***：重载的是运算对象的类型和返回值的类型，但运算对象的个数、运算符优先级和结合律无法改变。



**左值、右值**

C++表达式要么是左值，要么是右值。

在C中：可以位于赋值语句左侧的表达式是左值，反之是右值。

 在C++中：使用对象的值（即内容）的时候，对象是右值；使用对象的身份（即内存）的时候，对象是左值。左值可作为右值使用，但右值不可作为左值使用。

区分左右值的原因：不同的运算符对运算对象的要求可能是左值，也可能是右值；返回值可能是左值，也可能是右值。

- 赋值运算符左侧是左值，运算结果仍然是左值，如`((d = c) = b )= a`先将c赋值给d，返回左值d，再将b赋值给左值d，再次返回左值d，再将a赋值给左值d，所以最后d = a，而c,b,a值均不变
- 取地址符作用于左值对象，返回一个指针，该指针是右值。
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值。
- 递增递减运算符作用于左值；前置返回递增或递减后的左值，后置返回原右值。

`decltype`作用于左值时返回的是引用类型，如`int *p = &a; decltype(*p)`得到`int &`。



### 4.1.2 优先级与结合律

高优先级运算符的运算对象比低优先级运算符的运算对象更紧密组合在一起；优先级相同时，组合规则由结合律确定。



### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但没有说明运算对象的求值顺序。`int i = f1() * f2()`无法确定f1和f2谁先被调用。再比如：

`idx != s.size() && !isspace(s[idx])`中，`!`优先级最高，只是说明优先考虑其与对象结合，但不会优先计算。

**4种明确规定了运算对象求值顺序的运算符**：

- 逻辑与`&&`，规定先求左侧运算对象的值，只有左侧运算对象值为真时才继续求右侧运算对象的值
- 逻辑或`||`，规定先求左侧运算对象的值，只有左侧运算对象值为假时才继续求右侧运算对象的值
- 条件`?:` `cond ? expr1:expr2`先求cond值，为真对expr1求值并返回该值，否则对expr2求值并返回该值
- 逗号运算符`,` 从左到右依次计算



## 4.2 算术运算符

正负号（+ -）、乘除取余（* / %）、加减法（+ -），优先级依次降低。

算术运算符结果都是右值。



## 4.3 逻辑和关系运算符

逻辑非`!`、关系运算符`< <= > >=     != ==`、逻辑与`&&`、逻辑非`||`，优先级依次i降低

```c++
if (a != nullptr && b != nullptr) {} //放心使用

if (i < j < k) {} //错误， i < j是bool

if (i < j && j < k) {} //正确， 关系运算符优先级高于&&
```



***测试算术对象或指针对象！***

```c++
if (val){}  //合法，大胆用，先val转换为bool,非0为真，0为假
if (!val){} //合法，大胆用，先val转换为bool,非0为真，0为假，再取反
```



## 4.4 赋值运算符

赋值运算符优先级较低。

```c++
int i = get_value();
while (i != 42) {
    //其他处理
    i = get_value();
}

//更推荐的写法
while ((i = get_value()) != 42) {  //赋值语句返回了一个左值
    //其他处理
}
```



## 4.5 递增和递减运算符

前置版本得到递增或递减之后的值；后置版本得到递增或递减前的值。

除非必须，否则不用后置版本（因为需要存储原始值以便于返回这个未修改的内容，在相对复杂的迭代器类型，这种额外的工作消耗巨大）。



***混用解引用和递增运算符！***

后置递增运算符优先级高于解引用运算符

```c++
auto iter = v.begin();
while (iter != v.end() && *iter > 0) {
    cout << *iter++ << endl; //获取当前值，并将iter向后移动一个元素
}
/*
cout << *iter++ << endl;
等价于：
cout << *iter << endl;
++iter;
*/
```



## 4.6 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`，括号不可少。



## 4.7 条件运算符

***cond ? expr1 : expr2***

先对cond求值，为真则对expr1求值并返回该值；否则对expr2求值并返回该值

**嵌套条件运算符**

```c++
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass"
```

嵌套最多两到三层，否则代码可阅读性极具下降。



## 4.8 位运算符

位运算符如何处理运算对象的符号位依赖于机器。强烈建议仅将位运算符用于处理无符号类型。



## 4.9 sizeof运算符

注意sizeof是运算符，不是函数。

- 对解引用指针指向sizeof得到指针指向类型的大小，不需要指针有效
- 对数组执行sizeof得到整个数组所占空间的大小（`sizeof(arr)/sizeof(*arr)`元素个数）
- 对string或vector执行sizeof只返回该类型固定部分的大小，不会计算对象元素占用了多少空间。



## 4.10 逗号运算符

```c++
++idx, --cnt; //从左到右依次计算
```



## 4.11 类型转换

### 4.11.3 显示转换

显示转换，即程序员有目的的强制转换

**命名的强制类型转换**

`cast-name<type>(typename)`

- ***static_cast*** 任何具有明确定义的类型转换（除底层const)，都可以使用`static_cast`

  找回`void *`指针中的值(确保指针的值不变)：

  ```c++
  void *p = &d;
  double *dp = static_cast<double *>(p);
  ```

- ***const_cast*** 只能改变底层const

  ```c++
  const char *pc;
  char *p = const_cast<char *>(pc);//正确，但通过p写值是未定义行为
  ```

  如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；如果对象是常量，再使用const_cast执行写操作是非法不允许的。

- ***reinterpret_cast*** 为运算对象提供较低层次上的重新解释。

  在读写二进制文件时可使用，如将int写入文件，获得int的指针

  ```c++
  int value;
  char *pc = reinterpret_cast<char *>(&value);
  ```

  ***牢记转换前的类型！！！***

- ***dynamic_cast*** 支持运行时类型识别

