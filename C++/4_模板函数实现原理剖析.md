**模板函数与普通函数的区别**

- 函数模板不允许自动类型转化
- 普通函数能够自动进行类型转化



**函数模板的实例化**

编译时，只有在模板被调用且找不到对应模板的实例化函数时才会实例化模板。

例如，有以下几个源程序：

- A程序中，未使用到模板
- B程序在A程序的基础上添加了函数模板，但程序内部未调用模板
- C程序在B程序调用了一次函数模板，假定类型参数为int
- D程序在C程序的基础上再次调用了一次函数模板，假定类型参数为double
- E程序在D程序的基础上增加了一次函数模板调用，假定类型参数为int

结果如下：

- A程序与B程序的汇编代码无差异（因为函数模板只有在调用且不会造成重复实例化时才会实例化函数模板）
- B程序与C程序的差异在于，C程序对函数模板进行了一次实例化，实例化的模板函数参数类型为int
- C程序与D程序的差异在于，D程序对函数模板进行了二次实例化，实例化的模板函数参数类型分别是int和double
- E程序与D程序的在函数模板的实例化上无差异



**模板的声明与定义都需写在.h文件的原因分析**

因为C++分离式编译的规则导致。

普通情况下，在编译单个cpp文件时，如果遇到函数的调用，该cpp内只需要对该函数进行声明即可，函数被调用的位置会使用符号进行代替。函数的定义在另一个cpp内被编译。最后通过链接，函数调用的位置就能找到函数的定义。

假设模板的声明与定义分别写在h和cpp文件中，在编译一个调用了模板函数的cpp时（该cpp包含了模板的h头文件），由于只有声明没有定义，编译器此时无法实例化函数模板，按照普通规则，此处的函数调用位置使用符号代替，通过后续的链接来找到函数的具体定义。但是在编译包含函数模板的定义的cpp时，由于该cpp中并没有调用模板，也就不会对模板进行实例化。因此最终导致链接错误。



**控制模板的实例化与分离式编译**



**类模板中static关键字**

- 从类模板实例化的每一个模板类有自己的类模板数据成员，实例化的模板类的所有对象共享一个static数据成员
- 同一个类模板实例化的多个模板类的static并不相关

